<?php

/**
 * @file
 * Defines hooks and common functionality for the Entity Synchronization module.
 */

use Drupal\Core\Entity\EntityInterface;
use Drupal\Core\Entity\ContentEntityInterface;

/**
 * Hooks.
 */

/**
 * Implements hook_toolbar_alter().
 */
function entity_sync_toolbar_alter(&$items) {
  $items['administration']['#attached']['library'][] = 'entity_sync/toolbar';
}

/**
 * Implements hook_entity_update().
 */
function entity_sync_entity_update(EntityInterface $entity) {
  entity_sync_export_local_entity_all_syncs($entity);
}

/**
 * Internal API.
 */

/**
 * Exports the given entity as defined by any synchronization configuration.
 *
 * We detect which synchronizations define an enabled export operation for the
 * given entity type and we run them.
 *
 * @param \Drupal\Core\Entity\ContentEntityInterface $entity
 *   The entity to export. Right now we only support content entities.
 *
 * @I Move to a `exportLocalEntityAllSyncs` method in the export entity manager
 *    type     : task
 *    priority : normal
 *    labels   : export, structure
 *    notes    : Important so we can better write unit tests.
 */
function entity_sync_export_local_entity_all_syncs(
  ContentEntityInterface $entity
) {
  $entity_type_id = $entity->getEntityTypeId();

  // @I Support caching syncs per entity type
  //    type     : improvement
  //    priority : normal
  //    labels   : export, performance
  //
  // @I Support filtering by bundle
  //    type     : bug
  //    priority : high
  //    labels   : config, export
  //    notes    : The entity bundle is optional in the synchronization
  //               configuration; however, if it is defined, it is be
  //               interpreted as if the export should only proceed if the
  //               bundle of the entity being exported is of the configured
  //               type.
  $syncs = \Drupal::service('entity_sync.config_manager')
    ->getSyncs([
      'entity' => ['type_id' => $entity_type_id],
      'operation' => [
        'id' => 'export_entity',
        'status' => TRUE,
      ],
    ]);
  if (!$syncs) {
    return;
  }

  $manager = \Drupal::service('entity_sync.export.entity_manager');
  foreach ($syncs as $sync) {
    // If we are coming from an entity update, we may be here because an entity
    // import triggered an entity insert/update hook. In that case, we don't
    // want to export the entity as that can cause a loop i.e. export the entity
    // to the remote which may cause the entity to be made available in the
    // recently modified list of entities, causing an import again which in turn
    // will trigger a `hook_entity_update` etc.
    //
    // If we are here as a result of a change that happened within Drupal e.g.
    // an entity edited via the UI, the remote changed field would not be
    // changed. While, if we are here as a result of an import, the original
    // remote changed field would be a timestamp earlier than the new remote
    // changed field.
    //
    // We therefore check for that, and if the original remote changed field is
    // earlier than the updated remote changed field then we do not export the
    // entity.
    $field_name = $sync->get('entity.remote_changed_field');
    $original_changed = $entity->original->get($field_name)->value;
    $updated_changed = $entity->get($field_name)->value;
    if ($original_changed < $updated_changed) {
      continue;
    }

    // @I Support queuing local entity exports
    //    type     : improvement
    //    priority : normal
    //    labels   : export, performance
    $manager->exportLocalEntity($sync->get('id'), $entity);
  }
}
